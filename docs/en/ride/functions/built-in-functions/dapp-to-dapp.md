# dApp-to-dApp Invocation Functions

| Name | Description | Complexity |
| :--- | :--- | :--- |
| [invoke](#invoke) | Invokes a dApp callable function, with [reentrancy restriction](#reentrancy) | 75 |
| [reentrantInvoke](#reentrantinvoke) | Invokes a dApp callable function, without reentrancy restriction | 75 |

## invoke

Invokes a dApp [callable function](/en/ride/functions/callable-function), with reentrancy restriction.

```ride
invoke(dApp: Address|Alias, function: String, arguments: List[Any], payments: List[AttachedPayments]): Any
```

`Any` means any valid type.

The `invoke` function can be used by a callable function of a [dApp script](/en/ride/script/script-types/dapp-script), but not by a [verifier function](/en/ride/functions/verifier-function), [account script](/en/ride/script/script-types/account-script) or [asset script](/en/ride/script/script-types/asset-script).

Via the `invoke` function, the callable function can invoke a callable function of another dApp, or another callable function of the same dApp, or  even itself, and then use the invocation results in subsequent operations. For details, see the [dApp-to-dApp Invocation](/en/ride/advanced/dapp-to-dapp) article.

:bulb: To ensure executing callable functions and applying their actions in the right order, initialize a [strict variable](/en/ride/variables/) by the return value of an `invoke` function.

The invocation can contain payments that will be transferred from the balance of the parent dApp to the balance of the invoked dApp. Payments are forbidden if the dApp invokes itself.

If a payment token is a smart asset, the asset script verifies the `invoke` as if it was [InvokeScriptTransaction](/en/ride/structures/transaction-structures/burn-transaction) with the following fields:
* `dApp`, `payments`, `function`, `args` indicated in the `invoke` function;
* `sender`, `senderPublicKey` of the dApp that performs the invocation;
* `id`, `timestamp`, `fee`, `feeAssetId` indicated in the original Invoke Script transaction;
* `version` = 0;

If the asset script denies the action, the Invoke Script transaction is either denied or saved on the blockchain as failed, see the [Transaction Validation](/en/blockchain/transaction/transaction-validation).

## Reentrancy Restriction<a id="reentrancy"></a>

The invocation stack generated by the `invoke` function must not contain invocations of the parent dApp after invocation of another dApp.

Let the parent dApp A invokes dApp B using the `invoke` function. Regardless of whether dApp B uses `invoke` or `reentrantInvoke`, the following invocation stacks will **fail**:

```
→ dApp A
   → dapp B
       → dApp A
```

```
→ dApp A
   → dapp B
      → dApp C
         → dApp A
```

The following invocation stacks are **valid**:

```
→ dApp A
   → dapp A
      → dapp A
```

```
→ dApp N
   → dapp A
   → dApp A
```

```
→ dapp N
   → dapp A
      → dapp B
   → dapp B
      → dapp A
      → dapp C
```

### Parameters

| Parameter | Description |
| :--- | :--- |
| dApp: [Address](/en/ride/structures/common-structures/address)&#124;[Alias](/en/ride/structures/common-structures/alias) | [Address](/en/blockchain/account/address) or [alias](/en/blockchain/account/alias) of a dApp to invoke |
| function: [String](/en/ride/data-types/string)&#124;[Unit](/en/ride/data-types/unit) | Name of a callable function. `unit` for a default function invocation |
| arguments: [List](/en/ride/data-types/list)[[Any](/en/ride/data-types/any)] | Parameters of a callable function. `unit` for a default function invocation |
| payments: [List](/en/ride/data-types/list)[[AttachedPayment](/en/ride/structures/common-structures/attached-payment)] | Payments to transfer from the parent dApp to the invoked dApp, up to 10 |

## Example

A user sends an Invoke Script transaction that invokes the callable function `foo` of dApp1.

The `foo` function invokes the `bar` function of dApp2 passing the number `a` and attaching a payment of 1 USDN.

The `bar` function transfers 1 WAVES to dApp1 and returns the doubled number `a`.

The `foo` function writes to dApp1 data storage:
* the value returned by `bar`,
* the new balance of dApp2 (reduced by 1 WAVES transferred to dApp1).

dApp1:

```scala
{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

@Callable(i)
func foo(dapp2: String, a: Integer, key1: String, key2: String) = {
   strict r = invoke(addressFromStringValue(dapp2),bar,[a],[AttachedPayment(base58'DG2xFkPdDwKUoBkzGAhQtLpSGzfXLiCYPEzeKH2Ad24p',1000000)])
   (
      [
         IntegerEntry(key1, r),
         IntegerEntry(key2, wavesBalance(dapp2).regular)
      ],
      unit
   )
}
```

dApp2:

```scala
{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

@Callable(i)
func bar(a: Int) = {
   let 
   (
      [
         ScriptTransfer(i.caller, 100000000, unit),
      ],
      a*2
   )
}
```

## reentrantInvoke

Invokes a dApp [callable function](/en/ride/functions/callable-function). The only difference from the [invoke](#invoke) function is that there is no [reentrancy restriction](#reentrancy) for the parent dApp that uses `reentrantInvoke`.

However, if the parent dApp is invoked again and this time uses the `invoke` function, the parent dApp cannot be invoked again in this invocation stack.

For example, the invocation stack

```
→ dApp A
   → dapp B
      → dApp A
         → dApp C
            → dApp A
```

* is **valid** if dApp A invokes both dApp B and dApp C via the `reentrantInvoke` function;
* **fails** if dApp A invokes dApp B via the `reentrantInvoke` function and invokes dApp C via the `invoke` function.

```ride
reentrantInvoke(dApp: Address|Alias, function: String, arguments: List[Any], payments: List[AttachedPayments]): Any
```
