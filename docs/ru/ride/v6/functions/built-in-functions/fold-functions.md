# [Ride v6] Функции свертки

:warning: Это документация Стандартной библиотеки версии 6, которая в настоящее время доступна только на [Stagenet](/ru/blockchain/blockchain-network/). 

| Название | Описание | Сложность |
| :--- | :--- | :--- |
| [fold](#fold) | Семейство функций.<br>Реализуют операции над списком значений | 3–115 |

## fold

Семейство функций свертки. Позволяют реализовать операции над списком значений, такие как суммирование (`sum`), фильтрация (`filter`), преобразование (`map`), агрегация элементов (`zip`), проверка наличия (`exists`) и т.&thinsp;п. Аналогичны функциям свертки `fold` или `reduce` в других языках программирования.

| Название | Макс. эл-в | Сложность |
|:---| :--- | :--- |
| fold_20(list: List[A], accumulator: B, function: (B, A) => B): B | 20 | 3 |
| fold_50(list: List[A], accumulator: B, function: (B, A) => B): B | 20 | 7 |
| fold_100(list: List[A], accumulator: B, function: (B, A) => B): B | 20 | 9 |
| fold_200(list: List[A], accumulator: B, function: (B, A) => B): B | 20 | 20 |
| fold_500(list: List[A], accumulator: B, function: (B, A) => B): B | 20 | 56 |
| fold_1000(list: List[A], accumulator: B, function: (B, A) => B): B | 20 | 115 |

Общая сложность вызова `fold_<N>` включает в себя сложность, указанную в таблице, и сложность функции `function`, умноженной на `N`.

Свертка `fold_<N>(list, accumulator, function)` означает:

* выполнить не более `N` итераций;
* на каждой итерации: взять результат предыдущей итерации (на первой итерации взять значение `accumulator`) и следующий элемент списка `list`, применить к этой паре функцию `function`;
* вернуть итоговый результат.

Если в списке оказалось больше `N` элементов, функция `fold_<N>` завершается ошибкой.

### Параметры

| Параметр | Описание |
| :--- | :--- |
| `list` | Список значений |
| `accumulator` | Начальное значение |
| `function` | Cворачиваемая функция. Получает на вход два параметра: промежуточный результат и очередной элемент списка |

### Примеры

#### Суммирование

```scala
func sum(accum: Int, next: Int) = accum + next
let arr = [1,2,3,4,5]
fold_20(arr, 0, sum)    # Результат: 15
```

#### Произведение

```scala
func mult(accum: Int, next: Int) = accum * next
let arr = [1,2,3,4,5]
fold_20(arr, 1, mult)    # Результат: 120
```

#### Фильтрация

Следующий код формирует массив, состоящий только из четных элементов исходного массива.

```scala
func filterEven(accum: List[Int], next: Int) =
   if (next % 2 == 0) then accum :+ next else accum
let arr = [1,2,3,4,5]
fold_20(arr, [], filterEven)    # Результат: [2, 4]
```

#### Преобразование

Следующий код инвертирует массив, уменьшая каждый элемент на единицу:

```scala
func map(accum: List[Int], next: Int) = (next - 1) :: accum
let arr = [1, 2, 3, 4, 5]
fold_20(arr, [], map)    # Результат: [4, 3, 2, 1, 0]
```

