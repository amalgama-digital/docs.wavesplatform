# Переменные

В Ride вы можете объявить переменную только вместе с присвоением значения. Справа от знака `=` должно находиться [выражение](/ru/ride/base-concepts/expression). Значение переменной — результат выражения. 

Значение переменной в дальнейшем **недоступно для изменения**.

Ride строго типизирован, а тип переменной определяется исходя из значения.

## Ленивые переменные

Ключевое слово `let` используется для определения переменной с ленивой инициализацией: значение переменной вычисляется только при первом обращении к ней.

Примеры:

```scala
let a = 42                 # Определение целочисленной переменной
let b = "Ride the Waves!"  # Определение строковой переменной
```

Ленивую переменную можно определить глобально (в рамках скрипта), внутри любой функции или даже внутри определения переменной.

```scala
func lazyIsGood() = {
  let c = {
     let d = 1
     true
    }  
  c
}
```

Функция, определенная выше, возвращает значение `true`, но переменная `d` не будет инициализирована: значения неиспользуемых ленивых переменных не вычисляются.

Так как [функция](/ru/ride/functions/) является [определением](/ru/ride/base-concepts/definition), а не [выражением](/ru/ride/base-concepts/expression), то переменной можно присвоить значение функции, но не саму функцию.

``` ride
let result = lazyIsGood()  # значение result равно true
```

## Нетерпеливые переменные

Ключевое слово `strict` используется для определения переменной с нетерпеливой инициализацией: значение нетерпеливой переменной вычисляется сразу, когда исполнение скрипта доходит до нее, то есть перед следующим выражением.

Определить нетерпеливую переменную можно только внутри другого определения, например, внутри тела функции. Значение нетерпеливой переменной не будет вычислено, если она определена внутри другого определения, которое не используется: например, внутри функции, которую не вызвали.

Применение нетерпеливой переменной для [вызова dApp из dApp](/ru/ride/advanced/dapp-to-dapp) гарантирует порядок выполнения функций и применения действий скрипта. Пример:

```scala
func foo() = {
   ...
   strict balanceBefore = wavesBalance(this).regular
   strict z = invoke(dapp2,"bar",args,[AttachedPayment(unit,100000000)])
   strict balanceAfter = wavesBalance(this).regular

   if(balanceAfter < balanceBefore) then ... else...
}
```

В этом примере значения `balanceBefore` и `balanceAfter` могут отличаться, поскольку на балансе отражаются платежи в пользу `dApp2` и действия, выполненные вызываемой функцией `bar`.

# Встроенные переменные

Стандартная библиотека содержит [встроенные переменные](/ru/ride/variables/built-in-variables), которые вы можете использовать в скриптах.
