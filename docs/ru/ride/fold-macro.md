# Макрос FOLD&lt;N&gt;

Макрос `FOLD<N>` позволяет реализовать операции над списком значений, такие как суммирование (`sum`), фильтрация (`filter`), преобразование (`map`), агрегация элементов (`zip`), проверка наличия (`exists`) и т.&thinsp;п. Он работает аналогично функции свертки `fold` или `reduce` в других языках программирования.

```
FOLD<N>(list, start, foldFunc)
```

| Параметр | Описание |
| :--- | :--- |
| `N` | Максимальное количество итераций, не более 1000 |
| `list` | Список значений |
| `start` | Начальное значение |
| `foldFunc` | Cворачиваемая функция |

Сворачиваемая функция получает на вход два параметра: промежуточный результат и очередной элемент списка. Макрос `FOLD<N>(list, start, foldFunc)` означает:

* выполнить не более `N` итераций;
* на каждой итерации: взять результат предыдущей итерации (на первой итерации взять значение `start`) и следующий элемент списка `list`, применить к этой паре функцию `foldFunc`;
* вернуть итоговый результат.

Величина `N` должна быть известна заранее. Если в списке оказалось больше элементов, чем указано в FOLD, выполнение скрипта завершается ошибкой.

Сложность `FOLD<N>` соответствует сложности сворачиваемой функции, умноженной на `N`, плюс накладные расходы.

Макрос `FOLD<N>` — синтаксический сахар, он «раскрывается» на этапе компиляции кода. Поэтому, в частности, размер скрипта растет линейно с ростом `N`.

## Суммирование

```scala
func sum(accum: Int, next: Int) = accum + next
let arr = [1,2,3,4,5]
FOLD<5>(arr, 0, sum)    # Результат: 15
```

> Выражение 
> 
> ```scala
> FOLD<5>(arr, 0, sum)
> ``` 
> 
> после компиляции и декомпиляции будет выглядеть так:
> 
> ```scala
> let $l = arr
> let $s = size($l)
> let $acc0 = 0
> func 1 ($a,$i) =     if (($i >= $s))
>    then $a
>    else sum($a, $l[$i])
>
> func 2 ($a,$i) =     if (($i >= $s))
>    then $a
>    else throw("List size exceeds 5")
>
> 2(1(1(1(1(1($acc0, 0), 1), 2), 3), 4), 5)
> ```

> Такой код вы можете увидеть в Waves Explorer. [Пример](https://testnet.wavesexplorer.com/tx/GaLfaidadeowoZ4vMtEVvJK8RkJiqr5AdPWLvPtTnV4e)

## Произведение

```scala
func mult(accum: Int, next: Int) = accum * next
let arr = [1,2,3,4,5]
FOLD<5>(arr, 1, mult)    # Результат: 120
```

## Фильтрация

Следующий код формирует массив, состоящий только из четных элементов исходного массива.

```scala
func filterEven(accum: List[Int], next: Int) =
   if (next % 2 == 0) then accum :+ next else accum
let arr = [1,2,3,4,5]
FOLD<5>(arr, [], filterEven)    # Результат: [2, 4]
```

## Преобразование

Следующий код инвертирует массив, уменьшая каждый элемент на единицу:

```scala
func map(accum: List[Int], next: Int) = (next - 1) :: accum
let arr = [1, 2, 3, 4, 5]
FOLD<5>(arr, [], map)    # Результат: [4, 3, 2, 1, 0]
```
